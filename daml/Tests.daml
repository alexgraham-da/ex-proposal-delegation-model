module Tests where

import DA.Optional
import DA.Next.Set hiding (null)

import Daml.Script

import Model.Company
import Model.Proposal
import Model.Notification

import Setup

type ContractPair a = (ContractId a, a)

data TestContracts = TestContracts with
  cA         : ContractPair Company
  caInternal : ContractPair CompanyInternal
  cB         : ContractPair Company
  cbInternal : ContractPair CompanyInternal
    deriving (Show,Eq)

-- type Results a = Script (LedgerParties, a)
data Results a = Results with
  ledgerParties : LedgerParties
  payload       : a

results : LedgerParties -> a -> Script (Results a)
results ledgerParties payload = return $ Results with ..

type Step a = Script (Results a)

findOrCreate : (Template t, TemplateKey t k) => Party -> t -> Script (ContractId t, t)
findOrCreate party contract = do
  opt <- queryContractKey party (key contract)
  case opt of
    (Some c) -> return c
    None     -> (,) <$> submit party (createCmd contract) <*> return contract

reinitialize : LedgerParties -> Script TestContracts
reinitialize (LedgerParties public companyA companyB a1 a2 b1 b2) = do
  cA         <- findOrCreate companyA $ Company with owner = companyA, name = "Company A", observers = [public]
  caInternal <- findOrCreate companyA $ CompanyInternal with company = snd cA, employees = fromList [a2], management = [a1]
  cB         <- findOrCreate companyB $ Company with owner = companyB, name = "Company B", observers = [public]
  cbInternal <- findOrCreate companyB $ CompanyInternal with company = snd cB, employees = fromList [b2], management = [b1]

  return $ TestContracts cA caInternal cB cbInternal

testInit : Script (Results (ContractId Proposal))
testInit = allocateParties >>= initializeTests

initializeTests : LedgerParties -> Step (ContractId Proposal) -- Script (Results (ContractId Proposal))
initializeTests lp@(LedgerParties public companyA companyB a1 a2 b1 b2) = do
  tc@(TestContracts (caId, cA) (caInternalId, caInternal) (cbId, cB) (cbInternalId, cbInternal)) <- reinitialize lp

  -- add employeeA2 as a manager
  managerIdA <- companyA `submit` createCmd EmployeeManager with employee = a2, company = cA

  -- add employeeB2 as a manager
  managerIdB <- companyB `submit` createCmd EmployeeManager with employee = b2, company = cB

  -- add employees to company
  a2 `submit` exerciseCmd managerIdA EmployeeManager_AddEmployee with newEmployee = a1, name = "Employee A1"
  a2 `submit` exerciseCmd managerIdA EmployeeManager_AddEmployee with newEmployee = a2, name = "Employee A2"
  b2 `submit` exerciseCmd managerIdB EmployeeManager_AddEmployee with newEmployee = b1, name = "Employee B1"
  b2 `submit` exerciseCmd managerIdB EmployeeManager_AddEmployee with newEmployee = b2, name = "Employee B2"

 -- add employeeA1 as a reviewer
  a1Reviewer <- a2 `submit` exerciseCmd managerIdA EmployeeManager_AddReviewer with newReviewer = a1

  -- add employeeB1 as a submitter
  b1Proposer <- b2 `submit` exerciseCmd managerIdB EmployeeManager_AddProposer with newProposer = b1

  proposalId <- b1 `submit` exerciseCmd b1Proposer EmployeeProposer_MakeProposal with
      proposedTo = companyA, proposalText = "B1 proposing to Company A"

  results lp proposalId

type TestSetupResults = (LedgerParties,ContractId Proposal)

-- >> CompanyA trigger creates DelegatedProposals

testStepTwo : Results (ContractId Proposal) -> Step Proposal
testStepTwo (Results lp@(LedgerParties public companyA companyB a1 a2 b1 b2) proposalId) = do
  (TestContracts (caId, cA) (caInternalId, caInternal) (cbId, cB) (cbInternalId, cbInternal)) <- reinitialize lp

  proposal <- fromSome <$> queryContractId companyA proposalId

  -- EmployeeA2 is not a reviewer
  assertMsg "Employee A2 is not a reviewer, so should not have a proposal contract"
    =<< isNone <$> queryDelegatedProposal caInternal proposal a2

  -- EmployeeA1 should have a delegated proposal
  someDelegatedProposal1 <- queryDelegatedProposal caInternal proposal a1
  assertMsg "delegated proposal not found for employee A1" $ isSome someDelegatedProposal1

  let (dpId,_) = fromSome someDelegatedProposal1
  a1 `submit` exerciseCmd dpId DelegatedProposal_Accept

  results lp proposal

  where
    queryDelegatedProposal : CompanyInternal -> Proposal -> Party -> Script (Optional (ContractPair DelegatedProposal))
    queryDelegatedProposal internal proposal employee = queryContractKey employee $ key DelegatedProposal with ..

-- >> CompanyA trigger resolves proposal action
-- >> CompanyB trigger notifies employees

testStepThree : Results Proposal -> Step Agreement -- Script (Results Agreement)
testStepThree (Results lp@(LedgerParties public companyA companyB a1 a2 b1 b2) p) = do
  (TestContracts (caId, cA) (caInternalId, caInternal) (cbId, cB) (cbInternalId, cbInternal)) <- reinitialize lp

  let (Proposal proposer proposedTo proposal) = p
  let agreement = Agreement with proposer = proposer, proposedTo = proposedTo, text = proposal

  someAgreement <- queryContractKey @Agreement companyA $ key agreement
  assertMsg "agreement not found" $ isSome someAgreement

  let notification = Notification with sender = companyB, receiver = b1, message = ("The proposal: '" <> proposal <> "' was accepted.")
  notifications <- query @Notification b1
  assertMsg "employees of company b must have been notified" $ not $ null notifications

  results lp agreement

-- >> CompanyA/CompanyB triggers create Exposed contracts

testStepFour : Results Agreement -> Step ()
testStepFour (Results lp@(LedgerParties public companyA companyB a1 a2 b1 b2) agreement) = do
  (TestContracts (caId, cA) (caInternalId, caInternal) (cbId, cB) (cbInternalId, cbInternal)) <- reinitialize lp

  someExposedAgreementA <- queryContractKey @ExposedAgreement a1 (companyA, agreement)
  assertMsg "exposed agreement not found for employee of company A" $ isSome someExposedAgreementA

  someExposedAgreementB <- queryContractKey @ExposedAgreement b1 (companyB, agreement)
  assertMsg "exposed agreement not found for employee of company B" $ isSome someExposedAgreementA

  results lp ()
