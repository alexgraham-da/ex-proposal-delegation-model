module Templates where


template Notification
  with
    sender : Party
    receiver : Party
    message : Text
  where
    signatory sender
    observer receiver
    controller receiver can
      Notification_Dismiss : ()
        do return ()

template Employee
  with
    party : Party
    name : Text
  where
    signatory party

data CompanyKey = CompanyKey with
        owner : Party
        name  : Text
    deriving (Show, Eq)

template Company
  with
    owner : Party
    name : Text
    observers : [Party]
  where
    signatory owner
    observer observers
    key CompanyKey with
      owner, name : CompanyKey
    maintainer key.owner
    controller owner can
      Company_UpdateName : ContractId Company
        with
          newName : Text
        do
          create this with name = newName

    nonconsuming choice Company_Propose : ContractId Proposal
      with
        proposer : Party
        proposal : Text
      controller proposer
      do
        create Proposal with proposer, proposedTo = owner, proposal

    nonconsuming choice Company_AcceptProposal : ()
      with
        proposal : Proposal
        company : Party
      controller company
      do
        exerciseByKey @Proposal (key proposal) Proposal_Accept

template Proposal
  with
    proposer : Party
    proposedTo : Party
    proposal : Text
  where
    signatory proposer
    observer proposedTo
    key (proposer, proposedTo, proposal) : (Party, Party, Text)
    maintainer key._1
    controller proposedTo can
      Proposal_Accept : ()
        do
          create Notification with
              sender = proposedTo
              receiver = proposer, message = "Your proposal: " <> proposal <> " was accepted."
          return ()
      Proposal_Reject : ()
        do
          create Notification with
              sender = proposedTo
              receiver = proposer, message = "Your proposal " <> proposal <> " was rejected."
          return ()

template DelegatedProposal
  with
    proposal : Proposal
    internal : CompanyInternal
    employee : Party
  where
    signatory (signatory internal)
    observer employee
    key (proposal, employee, internal) : (Proposal, Party, CompanyInternal)
    maintainer key._3.company.owner -- keyb._2

    controller employee can
      DelegatedProposal_Accept : ContractId DelegatedProposalAction
        do
          create DelegatedProposalAction with proposal = this, action = Accept, employee, internal

      DelegatedProposal_Reject : ContractId DelegatedProposalAction
        do
          create DelegatedProposalAction with proposal = this, action = Reject, employee, internal

data DPAction = Accept | Reject deriving (Show,Eq)

template DelegatedProposalAction
  with
    proposal : DelegatedProposal
    action : DPAction
    employee : Party
    internal : CompanyInternal
  where
    signatory employee
    observer (signatory internal)
    controller (signatory internal) can
      DelegatedProposalAction_Resolve : ()
        do
          case action of
            Accept -> exerciseByKey @Proposal (key proposal.proposal) Proposal_Accept
            Reject -> exerciseByKey @Proposal (key proposal.proposal) Proposal_Reject

data CompanyInternalKey = CompanyInternalKey with
        company : Company
    deriving (Show, Eq)

template CompanyInternal
  with
    company : Company
    employees : [Party]
    management : [Party]
  where
    signatory company.owner
    observer employees
    key CompanyInternalKey with
      company : CompanyInternalKey
    maintainer key.company.owner
    controller company.owner can
      CompanyInternal_AddEmployee : ContractId CompanyInternal
        with
          employee : Party
          manager : Bool
        do
          let management' = if manager
                            then employee :: management
                            else management
          create this with employees = employee :: employees, management = management'
    nonconsuming choice CompanyInternal_UpdateCompanyName : ContractId Company
      with
        employee : Party
        newName : Text
      controller employee
      do
        assertMsg "Employee must be in management" $ elem employee management
        exerciseByKey @Company (key company) Company_UpdateName with newName

    nonconsuming choice CompanyInternal_AcceptProposal : ()
      with
        proposal : DelegatedProposal
        employee : Party
      controller employee
      do
        -- assertMsg "Employee must be in company" $ elem employee employees
        exerciseByKey @Company (key company) Company_AcceptProposal with proposal = proposal.proposal, company = company.owner
        return ()

    nonconsuming choice CompanyInternal_MakeProposal : ContractId Proposal
      with
        employee : Party
        proposedTo : Party
        proposalText : Text
      controller employee
      do
        assertMsg "Employee must be in company" $ elem employee employees
        assertMsg "Cannot propose to own company" $ proposedTo /= this.company.owner
        let proposal = Proposal with proposer = this.company.owner, proposal = proposalText, ..
        create proposal
